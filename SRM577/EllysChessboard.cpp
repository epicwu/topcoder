#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
using namespace std;

int f[16][16][16][16];
bool vis[16][16][16][16];

class EllysChessboard {
public:
	int N;
	vector<int> x;
	vector<int> y;
	int minx,maxx,miny,maxy;
	void process(vector<int> &x)
	{
		int minVal = x[0];
		for (int i = 0; i < x.size();++i)
		minVal = min(x[i],minVal);
		for (int i = 0; i < x.size();++i)
		x[i]-=minVal;
	}
	int dis(int x,int y, int a,int b ,int c,int d)
	{
		int ans = abs(x - a);
		ans = max(abs(x - b),ans);
		ans = max(abs(y - c),ans);
		ans = max(abs(y - d),ans);
		return ans;
	}
	bool inside(int x,int y,int a,int b ,int c, int d)
	{
		if (x>=a && x <=b && y>=c && y<=d)
			return true;
		return false;
	}
	bool notEqual(int a,int b ,int c,int d,int aa,int bb,int cc,int dd)
	{
		if (a != aa) return true;
		if (b != bb) return true;
		if (c != cc) return true;
		if (d != dd) return true;
		return false;
	}
	void DP()
	{
		memset(f,127,sizeof(f));
		memset(vis,false,sizeof(vis));
		cout<<"INF="<<f[0][0][0][0]<<endl;
		int INF = f[0][0][0][0];
		for (int i = 0; i < x.size();++i)
			f[x[i]][x[i]][y[i]][y[i]] = 0;
		//for (int cnt = 0;cnt <N ;++cnt)
		//cout<<x[cnt]<<","<<y[cnt]<<endl; 
		for (int cnt = 0;cnt <=N ;++cnt)
		{
			for (int i1 = minx ; i1 <= maxx ; ++i1)
			for (int i2 = minx ; i2 <= maxx ; ++i2)
			for (int i3 = miny ; i3 <= maxy ; ++i3)
			for (int i4 = miny ; i4 <= maxy ; ++i4)
			{
				if (!vis[i1][i2][i3][i4] && f[i1][i2][i3][i4] != INF)
					for (int j = 0 ; j < N;++j)
					{
						int j1 = min(x[j],i1);
						int j2 = max(x[j],i2);
						int j3 = min(y[j],i3);
						int j4 = max(y[j],i4);
						if (notEqual(i1,i2,i3,i4,j1,j2,j3,j4))
						{
							//选中第ｊ个
							int cost = dis(x[j],y[j],i1,i2,i3,i4);
							for (int k = 0 ; k < N; ++k)
								if (k != j && inside(x[k],y[k],j1,j2,j3,j4) && !inside(x[k],y[k],i1,i2,i3,i4))
								cost += dis(x[k],y[k],j1,j2,j3,j4);
							if (f[i1][i2][i3][i4]+cost < f[j1][j2][j3][j4])
							{
								f[j1][j2][j3][j4] = min(f[j1][j2][j3][j4], f[i1][i2][i3][i4]+cost);
								vis[j1][j2][j3][j4] = false;
							}
						}
					}
				vis[i1][i2][i3][i4] = true;
			}
		}
	}
	int minCost(vector <string> board) {
		for (int i = 0 ; i < int(board.size());++i)
			for (int j = 0; j < int(board.size());++j)
				if (board[i][j] == '#')
				{
					x.push_back(i+j);
					y.push_back(i-j);
				}
		N = x.size();
		if (N ==0) return 0;
		process(x);
		process(y);
		minx = x[0];
		maxx = x[0];
		miny = y[0];
		maxy = y[0];
		for (int i = 0 ; i < N; ++i)
		{
			minx = min(minx,x[i]);
			miny = min(miny,y[i]);
			maxx = max(maxx,x[i]);
			maxy = max(maxy,y[i]);
		}
		DP();
		return f[minx][maxx][miny][maxy];
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	EllysChessboard *obj;
	int answer;
	obj = new EllysChessboard();
	clock_t startTime = clock();
	answer = obj->minCost(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"........","........","...#....",".#......",".......#","........","........","........"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 10;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"........","........","........","........","........","........","........","........"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {".#......","........","..#..#.#","...#..#.","........","...#...#","...#...#","........"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 58;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"##..####","#####..#","..#.#...","#..##.##",".#.###.#","####.###","#.#...#.","##....#."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 275;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"########","########","########","########","########","########","########","########"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 476;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Elly has a standard chessboard, divided into 8 by 8 unit square cells.
// She wants to place pebbles onto some of the cells.
// You are given a vector <string> board.
// The j-th character of the i-th element of board is '#' if she wants to put a pebble onto the cell (i, j), and it is '.' otherwise.
// 
// Initially the chessboard doesn't contain any pebbles.
// Elly places the pebbles one by one.
// The cost of adding a pebble is defined as follows.
// If this is the first pebble to be placed (i.e., the board is empty), it can be placed for free.
// Otherwise, the cost is the Manhattan distance (see Notes for the definition) to the most distant pebble that has already been placed on the board.
// 
// Return the minimal total cost of placing a pebble onto each chosen cell.
// 
// DEFINITION
// Class:EllysChessboard
// Method:minCost
// Parameters:vector <string>
// Returns:int
// Method signature:int minCost(vector <string> board)
// 
// 
// NOTES
// -The Manhattan distance between the cell (x1, y1) and the cell (x2, y2) is defined as |x1-x2| + |y1-y2|, where || denotes absolute value.
// 
// 
// CONSTRAINTS
// -board will contain exactly 8 elements.
// -Each element of board will contain exactly 8 characters.
// -Each character in board will be either '#' or '.'.
// 
// 
// EXAMPLES
// 
// 0)
// {"........",
//  "........",
//  "...#....",
//  ".#......",
//  ".......#",
//  "........",
//  "........",
//  "........"}
// 
// Returns: 10
// 
// Elly wants to put pebbles on three cells: (2, 3), (3, 1), and (4, 7). One of the optimal ways to do this is as follows:
// 
// First, put a pebble to (2, 3). It costs nothing.
// Next, put a pebble to (3, 1). It costs |2-3| + |3-1| = 3.
// Next, put a pebble to (4, 7). The Manhattan distance between (4, 7) and (2, 3) is 6, and the Manhattan distance between (4, 7) and (3, 1) is 7, so the cost is max(6, 7) = 7.
// 
// The total cost is 0 + 3 + 7 = 10.
// 
// 1)
// {"........",
//  "........",
//  "........",
//  "........",
//  "........",
//  "........",
//  "........",
//  "........"}
// 
// Returns: 0
// 
// 
// 
// 2)
// {".#......",
//  "........",
//  "..#..#.#",
//  "...#..#.",
//  "........",
//  "...#...#",
//  "...#...#",
//  "........"}
// 
// Returns: 58
// 
// 
// 
// 3)
// {"##..####",
//  "#####..#",
//  "..#.#...",
//  "#..##.##",
//  ".#.###.#",
//  "####.###",
//  "#.#...#.",
//  "##....#."}
// 
// Returns: 275
// 
// 
// 
// 4)
// {"########",
//  "########",
//  "########",
//  "########",
//  "########",
//  "########",
//  "########",
//  "########"}
// 
// Returns: 476
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
